# The financial tracker project

## Introduction
This document will describe the design I've developed for my university project. Here are the requirements for the project:

- Relational database
- 2 tables in relation
- Spring Boot as backend framework
- CRUD operation on tables
- Frontend is required
- Any frontend framework may be used
- The project doesn't have to use external APIs
- The project must be published on GitHub or Gitlab for presentation and defense
- Repository must be public
- The database dump must be included in the repository (Located at "/database-dump.sql" in project root, with auto-loading configuration in "/src/main/resources/data.sql")

According to these requirements, I have decided to build a personal finance tracker app. Project goal is to create a minimum viable web app that will demonstrate work databases.

Core features:

- Add transaction
- View transactions
- Edit transactions
- Delete transaction
- Find transaction
- Sort categories by expenses

Textual diagram of the architecture: User -> Frontend -> Controllers -> Services -> Repositories -> DB

In the following sections I will be describing architecture in the next sequence: DB -> Repositories -> Services -> Controllers -> Frontend

## Database Design

In this section I will provide a comprehensive overview of the relational database design used in this project. For relational support I will use H2 database.

### Core Entities

The database needs 2 tables representing 2 core entities in application's logic:
1. Categories
2. Transactions

The relation between entities in JPA will be unidirectional from categories to transactions.

#### Relations

Here's the relations between these 2 tables:
Categories --(1:M)--> Transactions

#### DB Attributes

In this section I will describe columns SQL attributes for each tables in the next format - [Column's name]: [Variable type] ([Attributes])

- Categories:
    1. id: bigint (auto increment; unique)
    2. type: varchar(12) (not null)
    3. name: varchar(50) (not null, unique)
- Transactions:
    1. id: bigint (auto increment; unique)
    2. category_Id: bigint (not null; foreign key from Categories(id), on delete restrict, create index)
    3. description: varchar(100) (default null)
    4. amount: decimal(10,2) (not null; check (amount >= 0))
    5. time: timestamp (default current_timestamp, not null)

Amount column in transactions table uses decimal to avoid errors in rounding.

#### Table Mapping to Classes

In this section I will describe table mapping to Java classes using JPA for ORM:
Classes:

        - @Entity
          @Table(name = "categories")
        Category:

            @Id
            @GeneratedValue(strategy = GenerationType.IDENTITY)
            1. id: Long

            @Enumerated(EnumType.STRING)
            @Column(name = "type", nullable = false, length = 12)
            2. type: enum(INCOME, EXPENSE)

            @Column(name = "name", nullable = false, unique = true, length = 50)
            3. name: String

        - @Entity @Table(name = "transactions")
        Transaction:

            @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
            1. id: Long

            @ManyToOne(fetch = FetchType.LAZY)
            @JoinColumn(name = "category_id", nullable = false)
            2. category: Category

            @Column(name = "description", length = 100)
            3. description: String

            @Column (name ="amount", precision = 10, scale = 2)
            4. amount: BigDecimal

            @Columnm(name = "time", nullable = false)
            5. time: Instant

#### Repositories

This section describes Spring Boot repositories to access data from the tables following DAO pattern:

- CategoryRepository:
    - Default CRUD methods
    - Custom methods:
        - Optional<Category> findByName (String name)
        - List<Category> findByType(CategoryType type)

- TransactionRepository:
    - Default CRUD methods
    - Custom methods:
        - List<Transaction> findByCategory(Category category)
        - List<Transaction> findByCategoryId(Long categoryId)
        - Boolean existsByCategoryId(Long categoryId)
        - List<Transaction> findAllByOrderByTimeDesc()




#### Database Dump

The project includes two SQL files for database initialization and documentation:

"src/main/resources/data.sql" file automatically fills the database with sample data on application startup. It contains INSERT statements only, as the table schema is automatically generated by JPA from entity classes.

## Service Design

This section will describe the service layer of the project, it holds all essential "business logic".

### Data Transfer Objects (DTOs)

Before going straight into service logic I will define the DTOs, these are intermediate objects between JPA entities and frontend.

CategoryDTO is representation of category:

```
    + class CategoryDTO:
        // Attributes
        - Long id
        - String name
        - CategoryType type
```

CategoryRequestDTO will be used for updating or creating a category:

```
    + class CategoryRequestDTO:
        // Attributes
        - String name
        - CategoryType type
```

CategoryExpenseSummaryDTO is a special DTO for aggregated data:

```
    + class CategoryExpenseSummaryDTO:
    // Attributes
    - Long categoryId
    - String categoryName
    - BigDecimal totalExpenses
```

TransactionDTO is representation of transaction:

```
    + class TransactionDTO:
        // Attributes
        - Long id
        - String description
        - BigDecimal amount
        - Instant time

        // Information from Category
        - Long categoryId
        - String categoryName
        - CategoryType categoryType
```

TransactionRequestDTO will be used by the frontend to interact with update or create a transaction:

```
    + class TransactionRequestDTO:
    // Attributes
    - String description
    - BigDecimal amount
    - Long categoryId
    - Instant time
```

ErrorResponceDTO will be use by the exception handler
```
  + class ErrorResponseDto
  // Attributes
      - Instant timestamp
      - int status
      - String error
      - String message
      - String path
```

### Mapping Entities to DTOs and vice versa

Instead of manually connecting JPA entities to DTOs I will use special mapping insterface called `MapStruct`. In this section I will define mappers.

Here's the mapper for categories:

```java
@Mapper(componentModel = "spring")
public interface CategoryMapper {
    // Maps Entity -> DTO
    CategoryDTO toDto(Category category);

    // Maps a List of Entities -> List of DTOs
    List<CategoryDTO> toDtoList(List<Category> categories);

    // Maps Request DTO -> Entity
    Category toEntity(CategoryRequestDTO requestDto);
}
```

Transaction mapper uses more difficult logic, since it has nested information from categories:

```java
@Mapper(componentModel = "spring", uses = {CategoryMapper.class})
public interface TransactionMapper {
    @Mapping(source = "category.id", target = "categoryId")
    @Mapping(source = "category.name", target = "categoryName")
    @Mapping(source = "category.type", target = "categoryType")
    TransactionDTO toDto(Transaction transaction);

    List<TransactionDTO> toDtoList(List<Transaction> transactions);

    // For converting the Request DTO, we ignore the category field
    // because we will set it manually in the service layer.
    @Mapping(target = "category", ignore = true)
    Transaction toEntity(TransactionRequestDTO requestDto);
}
```

### Services

The services contain the logic of the application, they work with data and present it through frontend. I will separate actual implementation of the logic through interfaces.

#### Interfaces

I this section I will describe the interaces separating the implementation logic:

```java
public interface CategoryService {
    CategoryDTO createCategory(CategoryRequestDTO request);
    List<CategoryDTO> getAllCategories();
    CategoryDTO getCategoryById(Long id);
    CategoryDTO updateCategory(Long id, CategoryRequestDTO request);
    void deleteCategory(Long id);
}
```



```java
public interface TransactionService {
    TransactionDTO createTransaction(TransactionRequestDTO request);
    List<TransactionDTO> getAllTransactions();
    TransactionDTO getTransactionById(Long id);
    TransactionDTO updateTransaction(Long id, TransactionRequestDTO request);
    void deleteTransaction(Long id);

    // Business Logic Method
    List<CategoryExpenseSummaryDTO> getCategoryExpenseSummary();
}

```

#### Service Implementation Logic

In this section I will describe the implemented logic of the application in the next format (custom exceptions are below the implementation):

@[Annotations]
[Class]{
[Methods and description of their work]
}

##### CategoryServiceImpl

@Service
@Transactional
public class CategoryServiceImpl implements CategoryService

1. CategoryDTO createCategory (CategoryRequestDTO request)
    - Validate that no category with the same name already exists (using CategoryRepository.findByName())
    - Convert CategoryRequestDTO to Category entity using CategoryMapper
    - Save the entity using CategoryRepository.save()
    - Convert saved entity back to CategoryDTO and return
    - Throws: DuplicateResourceException if name already exists

2. List<CategoryDto> getAllCategories()
    - Fetch all categories using CategoryRepository.findAll()
    - Convert list of entities to list of DTOs using CategoryMapper.toDtoList()
    - Return the DTO list (empty list if no categories exist)

3. CategoryDto getCategoryById(Long id)
    - Find category using CategoryRepository.findById(id)
    - If not found, throw ResourceNotFoundException with message "Category not found with id: {id}"
    - Convert found entity to CategoryDTO and return

4. CategoryDto updateCategory(Long id, CategoryRequestDTO request)
    - Find existing category by id (throw ResourceNotFoundException if not found)
    - Check if new name conflicts with another category (if name is being changed)
    - Update the entity fields with values from request
    - Save updated entity
    - Convert to CategoryDTO and return
    - Throws: ResourceNotFoundException, DuplicateResourceException

5. void deleteCategory(Long id)
    - Check if category exists (throw ResourceNotFoundException if not)
    - Check if category has associated transactions using TransactionRepository.existsByCategoryId()
    - If transactions exist, throw BusinessLogicException with message "Cannot delete category with existing transactions"
    - Delete category using CategoryRepository.delete(category)
    - Throws: ResourceNotFoundException, BusinessLogicException

##### TransactionServiceImpl

@Service
@Transactional
public class TransactionServiceImpl implements TransactionService

1. createTransaction(TransactionRequestDTO request)
    - Validate that categoryId is not null
    - Find category by categoryId (throw ResourceNotFoundException if not found)
    - Convert TransactionRequestDTO to Transaction entity using TransactionMapper
    - Manually set the category on the transaction entity (since mapper ignores it)
    - If request.time is null, set it to Instant.now() as default
    - Save the entity using TransactionRepository.save()
    - Convert saved entity to TransactionDTO and return
    - Throws: ResourceNotFoundException if category doesn't exist

2. getAllTransactions()
    - Fetch all transactions using TransactionRepository.findAll()
    - Convert list of entities to DTOs using TransactionMapper.toDtoList()
    - Return the DTO list sorted by time (most recent first)

3. getTransactionById(Long id)
    - Find transaction using TransactionRepository.findById(id)
    - If not found, throw ResourceNotFoundException
    - Convert entity to TransactionDTO and return

4. updateTransaction(Long id, TransactionRequestDTO request)
    - Find existing transaction by id (throw ResourceNotFoundException if not found)
    - If categoryId changed, validate new category exists
    - Update transaction fields with values from request
    - If category changed, fetch and set new category entity
    - Save updated entity
    - Convert to TransactionDTO and return
    - Throws: ResourceNotFoundException

5. deleteTransaction(Long id)
    - Check if transaction exists (throw ResourceNotFoundException if not)
    - Delete transaction using TransactionRepository.deleteById(id)
    - No restrictions on deletion

6. getCategoryExpenseSummary() (Business Logic Method)
    - Fetch all categories of type EXPENSE using CategoryRepository.findByType(CategoryType.EXPENSE)
    - For each expense category:
        - Find all transactions for this category using TransactionRepository.findByCategory(category)
        - Sum the amounts using Java stream
        - Create CategoryExpenseSummaryDTO with categoryId, categoryName, and totalExpenses
    - Sort the list by totalExpenses in descending order (highest expenses first)
    - Return the sorted list

7. getTransactionsByCategory(Long id)
    - Validate category exists
    - Fetch transactions
    - Convert List<Transaction> to DTO and return
    - Throws: ResourceNotFoundException

### Exception Handling

I will use custom exceptions to ease understanding the of potential errors:

1. ResourceNotFoundException
    - Thrown when a requested entity doesn't exist
    - HTTP Status: 404 NOT FOUND

2. DuplicateResourceException
    - Thrown when trying to create/update with a duplicate unique value
    - HTTP Status: 409 CONFLICT

3. BusinessLogicException
    - Thrown when a business rule is violated
    - HTTP Status: 400 BAD REQUEST

I will use @RestControllerAdvice to handle these custom exceptions.

## Controllers (API Endpoints)

This section describes controllers, they are responsible for interaction with "outside world".

### API Endpoint Design

#### Category Endpoints

1. GET /api/categories
    - Returns: List<CategoryDTO>
    - Purpose: Get all categories

2. GET /api/categories/{id}
    - Returns: CategoryDTO
    - Purpose: Get specific category details

3. POST /api/categories
    - Accepts: CategoryRequestDTO (in request body)
    - Returns: CategoryDTO (created category)
    - Purpose: Create new category

4. PUT /api/categories/{id}
    - Accepts: CategoryRequestDTO (in request body)
    - Returns: CategoryDTO (updated category)
    - Purpose: Update existing category

5. DELETE /api/categories/{id}
    - Returns: HTTP 204 No Content (on success)
    - Purpose: Delete category (if no transactions exist)

#### Transaction Endpoints

1. GET /api/transactions
    - Returns: List<TransactionDTO>
    - Purpose: Get all transactions

2. GET /api/transactions/{id}
    - Returns: TransactionDTO
    - Purpose: Get specific transaction details

3. POST /api/transactions
    - Accepts: TransactionRequestDTO (in request body)
    - Returns: TransactionDTO (created transaction)
    - Purpose: Create new transaction

4. PUT /api/transactions/{id}
    - Accepts: TransactionRequestDTO (in request body)
    - Returns: TransactionDTO (updated transaction)
    - Purpose: Update existing transaction

5. DELETE /api/transactions/{id}
    - Returns: HTTP 204 No Content (on success)
    - Purpose: Delete transaction

6. GET /api/transactions/category/{categoryId}
    - Returns: List<TransactionDTO>
    - Purpose: Find transactions by category (for your find transaction feature)

#### Business Logic Endpoints

1. GET /api/categories/expenses/summary
    - Returns: List<CategoryExpenseSummaryDTO>
    - Purpose: Sort categories by expenses feature

### Error Handling in Controllers

- ResourceNotFoundException: 404 with error message
- DuplicateResourceException: 409 with error message
- BusinessLogicException: 400 with error message
- ValidationException: 400 with field errors
- Generic Exception: 500 with generic message

## Frontend Layer

This section describes the web interface layer of the application, which uses server side rendering with Thymeleaf templates.

### Data Binding

The controller uses @InitBinder to handle conversion between HTML inputs and Java types:

### View Routes and Handlers

#### Main Page

1. GET /
    - Purpose: Display main dashboard with transactions and summary
    - Model Attributes:
    - transactions - List<TransactionDTO> (all transactions)
    - summary - List<CategoryExpenseSummaryDTO> (expense summary by category)
    - categories - List<CategoryDTO> (for dropdown)
    - newTransaction - empty TransactionRequestDTO
    - Returns: index template

#### Transaction Management

1. POST /transactions/add
    - Purpose: Create new transaction from form
    - Accepts: @ModelAttribute TransactionRequestDTO
    - Success: Redirects to "/" with success flash message
    - Returns: redirect:/

2. GET /transactions/edit/{id}
    - Purpose: Show edit form for existing transaction
    - Model Attributes:
    - transactionId - Long (transaction ID)
    - transactionRequest - TransactionRequestDTO (pre-filled)
    - categories - List<CategoryDTO> (for dropdown)
    - Returns: edit-transaction template

3. POST /transactions/update/{id}
    - Purpose: Update existing transaction from form
    - Accepts: @ModelAttribute TransactionRequestDTO
    - Success: Redirects to "/" with success flash message
    - Returns: redirect:/

4. GET /transactions/delete/{id}
    - Purpose: Delete transaction
    - Success: Redirects to "/" with success flash message
    - Returns: redirect:/

#### Category Management

1. GET /categories
    - Purpose: Display category management page
    - Model Attributes:
    - categories - List<CategoryDTO> (existing categories)
    - newCategory - empty CategoryRequestDTO (for add form)
    - Returns: categories template

2. POST /categories/add
    - Purpose: Create new category from form
    - Accepts: @ModelAttribute CategoryRequestDTO
    - Success/Error: Redirects to "/categories" with flash message
    - Exception Handling: Catches exceptions and displays error messages
    - Returns: redirect:/categories

3. GET /categories/edit/{id}
    - Purpose: Show edit form for existing category
    - Model Attributes:
    - categoryId - Long (category ID)
    - categoryRequest - CategoryRequestDTO (pre-filled with name and type)
    - Returns: edit-category template

4. POST /categories/update/{id}
    - Purpose: Update existing category from form
    - Accepts: @ModelAttribute CategoryRequestDTO
    - Success/Error: Redirects to "/categories" with flash message
    - Exception Handling: Catches exceptions and displays error messages
    - Returns: redirect:/categories

5. GET /categories/delete/{id}
    - Purpose: Delete category
    - Success/Error: Redirects to "/categories" with flash message
    - Exception Handling: Catches BusinessLogicException if category has transactions
    - Returns: redirect:/categories

### Flash Attributes

The controller uses RedirectAttributes to pass temporary messages between redirects:

- successMessage - Displayed as green alert on success
- errorMessage - Displayed as red alert on errors

### Form Binding Pattern

The controller uses the next algorithm for form handling to prevent duplicate submissions on page refresh:

1. Display Form: GET endpoint adds empty DTO to model
2. Submit Form: POST endpoint receives @ModelAttribute with bound data
3. Process: Calls service layer method
4. Redirect: Returns redirect with flash message

### Templates

The list of the rendered templates:

- index.html - Main dashboard
- edit-transaction.html - Transaction edit form
- categories.html - Category management page
- edit-category.html - Category edit form
